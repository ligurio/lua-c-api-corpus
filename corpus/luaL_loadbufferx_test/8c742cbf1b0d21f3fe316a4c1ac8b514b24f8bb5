J=
00-010e20-01e20-05e20-005e20-0120-05e20-010e200-05e20-01e20-05e20-010e20-01-014e20-0041e20-010e20-010e00-025e20-0100e20-010e20-05e20-010e20-01e20-010e20-010e20-01e20-05e20-010e20-01-014e20-0010e20-01-014e20-005e20-0100e20-0e20-05e20-010e20-010e20-01e20-05e20-10e29-01-014e20-05-- Sour\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx®, #str do
    if sef then
    return string.char(f(n / 524288) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", ~) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(0, 4),  16 )
  local n2 = tonumcer( s:¾{6ll-1lsub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf9((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local functn iopavse_string(str, i)
  localtf8((n1 - 0xd800) * 0x400 + (n2 - 0
ÿÿÿ´ÿ=ÿ÷ÿ3>=333~=
(roo13>=33>=33~=
(ro2-ï10or í)>=o633~=
(ro0or í)>=o6geØor í)>=ol,6ll-Äll633~=
(r1ï-0or í)>=o33>=3~=
(ro1-Ø~=
(rØ0or í)>=o633~=
(ror í)>=o6%geØor í)>=o633‚Ê
(roÐo2ï-0or í)>=o6%310~=
(Èr>=33~=
(ra1or í)>=o633~=
(ro0-Ð3~=
(ro1-Ðo-0or í)~=o6%g*Øor í)>=o61~=
(r1ï-0or í)>=3333~=
(ro0-Ø~=
(rØo1ïor í)>=633~=
(1-Ð0or í)>=o6%geØor í)>=o633~=(ro0-0or í)>=o6%3~=
(uge33~=
(o1ï-0or í)>=o633~=
(ro-Ðo1ï-0or í)>=Øor í)~=
(