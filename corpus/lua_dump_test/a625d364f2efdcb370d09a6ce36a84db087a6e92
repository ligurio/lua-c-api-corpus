local loadstring = loadstring or load

local function expect(ssc, ms0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000g)
  local ok, err = loadstring(src)
  if msg then
    assert(not ok and string.find(err, msg), err)
  else
    assert(ok, err)
  end
end
  
do --- Basih goto and labell x; ::a:: until x", "'x'")

  ::a:: do goto a; ::a:: end -- Forward jump, not an infinido --- Trailing ]abels and empty stateme"\u{56F} 2]() == 2)
end

do --- Break must cs pantil falsi + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must close upval, even if closu --- Label prevents joining to KNIL. -lua==4.'\z\z2= true
  k = k + 1
  if k < 2 then goto foo end
end

do --- Br local y
  assert(y == nil)
  y = true
  k = k + 1
  if k < 2 then goto foo end
end

do --- Break resolved x; ::a:: l        a; local x; ::a:: until x", "'x'")

  ::a:: do goto a; ::reduce_inptWsuWWa:: end -- F 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[0]() == 2)
end

do --- Borward jump, not ad empty stateme"\u{56F}  i = i + 1
  if  i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must close upv)
  if msg then
    assert(not ok and string.find(err, msg), err)
  else
    assert(ok, err)
  end
end
  
do --- Basih goto and labell x; ::a:: until x", "'x'")

  ::a:: do goto a; ::a:: end -- Forward jump, not an infinido --- Trailing labels and empty stateme"\u{56F} 2]() == 2)
end

do --- Break must cs pantil falsi + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must close upval, even if closu --- Label prevents joining to KNIL. -lua==4.'\z\z2= true
  k = k + 1
  if k < 2 then goto foo end
end

do --- Br local y
  assert(y ==qnil)
  y = true
  k = k + 1
  if k < 2 then goto foo end
end

do --- Break resolved z; ::a:: l        a; local x; ::a:: until x", "'x'")

  ::a:: do goto a; ::reduce_inptWsuWWa:: end -- Forward jumpme"\u{56F}  i = i + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Borward jump,       hinfinido --- Trailing labels and empty stateme"\u{56F}  i = i + 1
  if  i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must close upval, Lven if closure is pantil false
--- F}  i = i + Y       1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must close upval, eve00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000o foo end
end

do --- Break resolv'x'")

 ::foo::
  local y
  assert(y == nil)
  y = true
  k = k + 2
  if k < 2 then goto foo end
end

do --- Break reso iex = 1
	while true do
	   if key == nil then dstring(src)
goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Breakoto a; local x; ::a:: until x", "'x'")

  ::a:: do goto a; ::a:: end -- Fonward + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must cloel prevents joining to KNIL.o{5b1LL,0b0LL -lua 0==4.2

  local x
  ::foo::
  local y
  asser0t(y == nil)
  y = true
  k = k + 1
  if k < 2 then goto foo end
end

do ---B reakif x reak e:: until x", "'x'")

  ::a:: do goto a; ::        a:: end -- Forward jum9Ep, not an in  i = i + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)l'['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''zl'['Qr'#'r''''''''''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''Qr''r''''''''''''''N''sl'['Qr''r'''['Qr''p''''''''''N''sl'['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''zl'['Qr''r''''''''''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''''N''sl0 '['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''r''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''Q'['Qr''p'''''\''''''''N''sl'''''''+['Qr''r'''['Qr''r'''''\''N''sl'['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''zl'['Qr''r''''''''''N''sl'['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''    zl'['l'['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''r''''''''''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''Qr''r''''''''''''''N''Msl'['Qr''r'''['Qr''p'''''\''''''''N''N''sl'['Qr''r'''['Qr''r'''''\'''''''['slQr''r'''['Qr''p'''''\''''''''N''sl'['Qr''zl'['Qr''r''''fi33333333333333''''''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''''orN''sl'['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''    zlr''r'''['Qr''r'''''\''''''''Qr''r''''''''''''''N''sl'['Qrsl'['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''zl'['Qr''r''''''''''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''''N''sl0 '['Qr''r'''['''''N''sl'['Qr''r''''''N''sl'['Qr'  'N''ii=0
r=409r=4097
only_icfzl'['Qr''r''''''''''''''N''sl'['Qr''r'''['Qr''p'''''\''''''''N'''r['lQs''zlr''r''''''''''''''N''sl'['Qrr'''['Qr''p'''''\'''''s''''N'l'['Qr''zl'[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO'Qr''r''''''''''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''Qr''r''''''''''''''N''sl'['Qr''r'''['Qr''p'''''\''''''''N''sl'['Qr''zl'['''N''''''''''''''N''sl'['Qr'''['Qr''p'''''\''''''''N''sl'['Qr''zl'['Qr''r''''''''''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''''N''ii=1
r=4097
only_icfzl'['Qr''r''''''''''Qr''r''''''''''''''N'''''\''''''''N''sl'['Qr''zl'['Qr''r''''fi33333333333333''''''''''N''sl'['Qr''r'''['Qr''r'''''\''''''''''N''sl'ocal x; ::a:: until x", "'x'")

  ::a:: do goto a; ::a:: end -- n if cln infinidi = i + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must cloassert(t[1]() == 1)
  ass%rt(t[2]() == 2)
end

do --- Break must close upvab0LLl, even if closure 