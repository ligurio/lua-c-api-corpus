--[[i[[f ]] i[[     [f o33 0 6t(fact(5) == 120)
end
assert(fact == false)

-- testing declarations[a = {i = 10}
self = 20
function a:x (x) return x+self.i end
function a.y (x) == a.y(1))

a.t      f3332;rof6l=g   [f  ction (sel         si_{alue_pro10;333,o3333332<r9311111113;333,o3333332;ro,o_=0B1111111111111111111111111111111101111111111110,.0,.111110;33,B11f, a,b) retur 41    10S $        $ \u{5065}110 5 001#D0'0n self.i+a+b end

assert(a.t:x(4,3) == -95)

do
  local a = {x=0}
  function a:add (x) self
do if t then return i,2 end if t[i]	 then return i, t end if t[i]then_eturn 1i, t[i]+2 end  if t[i] then retur     8                    n i, t[i]+2 end  local  f.x, a.y = self.x+x, 20; returnsert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b=c{}}{

=}function a.b.c.f1 (x) return x+1 end
functi                                                                    unction ite()end
  local t s(t(t)          ~                                 on a.b.c:f2 (x,y) self[x] = y end
assert(a.b.c    4) == 5)
a.b.c:f2(a) return   [f  of6l=g33 0  [f  ]]i[[     f3332;rof6l=g33 0    [f  ]]i[[  f5l=o33 0    [f  ]]i[[f  ]]iU[[    0    [f  ]]111111111111111101111111111 recursf end

assert(a:x(1)+10 == a.ynd
funcal,i