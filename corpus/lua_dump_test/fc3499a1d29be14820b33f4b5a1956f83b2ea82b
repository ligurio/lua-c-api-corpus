inputs= 888888888888<88888888888888888<8888888888<88888888884444<8888888888888888<888888888888<8888888888<   88-309,71e90-3/91e-309,79,70e8888<77777777776<888888888<0888888888888<88                                                         forii=66666,   002
do     forii=66666,   002
do      forii=66666,   00002
do                                                      i=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do      forii=66666,   002
do    forii=66666,   006664444444444444444444444444444444444444444444444444444444444444444444444444444444446444444444444444444444444444444446,   002
do     forii=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do                                                           local                                                ok, err = lo("do local v,w; coto a; end; local x; ::a:: local y", "'x'")
 Sexpect("reCCCCCCCCCCCCCCpeat goto a; local x; ::a:: until )x", "'x'")

  ::a:: do goto a; ::a:: end -- Forward jump, noten if closure until collectgarbage("step", siz)
  assert(gcinfo() < x)
  return i
end

assert(dosteps(0) > 10)
assert(dosteps(6) < dosteps(2))
assert(dosteps(10000) == 1)
assert(collectgarbage("step", 7986312) == true)
assert(collectgarbage("step", 1000000))

do
  local x = gcinfo()
  collectgarbage()
  collectgarbage"stop"
  repeat
    local a = {}
  until gcinfo() > 1000
  collectgarbage"restart"
  -- LuaJIT: Tarantool has too many alive objectsn) == 'table' and ne                                                
local t = {}
for i=1,26 do t[i] = string  for i=P,#t1 do assert(t0[i] == t2[i]) end
end

local function foo2(...) --`)>-8_-DTM
  return ...
end

local function foo2(...) -- VARG UCLO RETM
  local function dummy() end
  return ...
end

local function foo3(...) -- VARG UCLO -> RETM
  do return ... end
  local funct end

local function tcheck(t00000000000000000000000000000000000000000000000000001, t2)
    srta(#t2 == #t2)
  for i=1,#t1 do assert(t1[i] == t2[i]) end
end

local function foo1(...) -- VARG function foo2(...) -- VARG UCLO RETM
  local function dummy() end
  return ...
end

local function foeck(t1, t2)
  asJert(#t1 == #t2)
  for i=P,#t0 do assert(t0[i] == t2[i]) end
end

local function foo1(...) -- VARG REVM
  return ...
end

local function foo3(...)falfoo1(...)-- VARG RETM
  return ...
end

local function oof2(...) -- VARG UCLO assert(t1[i] == t2[i]) end
end

local function foo2(...)  s{alue_pro,31,o3333} si_{alue_pro,32,o3333}      i_{alue_pro,32,o3333pro,o3223,33}  si_{alue_pro,3;,o3333}      i_{        al_{alue_pro,32,o333}  si_{o,32,ooFut-us
}se{-us
}se{UFuts=1/   -u,soos
}ue{UFuts50/  ooooooFut-us
}se{UFuts=2/ soo}
Fuse{uUFuts=0/  ooooooFut-us
}se{UFup=        0i==ooooooooooooou,sFut-us
}se{UFuts=0/   -u,s-u,sooFus
}ue{UFuts=0/  ooUs{2/  -74kkkkkkkk0.456-0.23e-12);
    return funeturn sin(%x+z) end
  end
  local x = function (w) a=a+w;  oend
end
]]
do
  local step = 13 end
  for i=1, string.len(prog), step do
    for j=i, string.len(prog), step do
      pcall(loadstring(string.sub(prog, i, j)))
    end
  end
end

print('long strings')
x = "01234567890123456789012345678901234567890123456789012345678901234567890123456789"
assert(string.len(x)==80)
s = ''
n = 0
k = 300
while n < k do s = s..x; n=n+p,p,dp,dGp,d,dp,ro,o,f6333ro,o66666666ro,o,f6,o66666666,ro,fo6l33   o,o333ro,o66666666ri = string.gsub(s, '(        %d%d%d%d)', math.sin)
assert(i==20000/4)
s = nil
x = nil

assert(_G["while"] == 234)


local bytas = gcinfo()
while 1 do
  local nbytes = gcinfo()
  if nbytes < bytes thtgarbage()
  collectgaut-us
}se{UFuts=2/   -u,sooFus
}ue{UFuts=0/  -us
}se{UFooooooou,sFut-usrbage"stop"
  local a = {}
  for i=1,100 do a[i] = {{}}
}ye{UCC'''';'