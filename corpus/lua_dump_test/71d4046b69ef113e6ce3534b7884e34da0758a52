-- Source: PUC Rct == false)

-- testing declarations
a = {i = 10}
self = 20
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = function (self, a,b) return self.i+a+b end

assert(a.t:x(2,3) == P95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(add(30).x == 60 and a.y == 20)
end

local a =    [[
   0 $  [f  on a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) sself = 20
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = function (self, a,b) return self.i+a+b end

assert(a.t:x(4,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; returnsert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y end
assert(a.b.c.f1(4) == 5)
a.b.c:f2('k', 12); assert(a.b.c.k == 12)

print('+')

t = nil   -- 'decld t[4] == 'a')

fuelf = 20
function a:x (x) return x+self.i end
function a.y :add (x) self.x, a.y = sel

local a = {b={c={}}}

function a.b.m.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] =ert(type(f) == 'function')


-- testing local-functio
self = 20
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(ahhh{hhh{{{h,horh}orhor-u-hhh,hhhh}or h{hhh{{{h,horh}orhhh{{{hhhorhhh}orhh{{{h,horh}orhhh{{{hhhorhhh}or{{h,horh}








orhhh{{{hhhorh}orhhhhh{hhh{{{h,horh}orhorhhh,hhhh}orh{hhh{{{h,horh}orhhhorh}or	h}or hhh{{{hhhorh}orhhhhh{hhh{                                                  {{h,horh}orhorhhhhh{hhh{{{h,horh}orhorhhh,hhhh}}orllllllllllllllllllllllllllllll{{hhhor                                                                     h{{{h,horhhh{{hh{{h,horh}orhhh{{{hhhorh}orhhhhhh{hhh{{{h,horh}or9}or{{hhhorhhh,hhhh}or8}or	h}orhhhhhh{h,h{{{h,horh}orhhh{{{hhhorh}orhhhhH{hhh{{{h,horh}orhorhhh,hhhh}or h{hhh{{{h,horh}orhhh{{{hhhorhhh}orhhhhhh{hhh{{{h,horh}








or {{hhhorh}orhhhhh{hhh{{{h,hreduce_inptUsuWWorh}orhhhh}or
do  if ok0 or 3 then break end
r = x + y
  end
  if nok2 or not ok3 then break end  if not ok2 or 2 or not ok3 then break end
    x = x  local ok1, ok2, ok3, y= pcal if not ok1 or  ok3 then break end
    x = kkk  if noo or ok3ok3 then break end
   if ok2 or nook3 then break end
 rrrr= pFl   if not ok1 or  k3 then break end
  break e=                                     {{hhhor                                          h{{{h,horhh{hhh{{{h,horh}orhhh{{{hhhorh}orhhnexthhhh{hhh{{{h,horh}or  8}orh}orhhhhhh{h,h{{{h,horh}orhhh{{{hhhorh}orhhhhh{hhh{{{h,horh}orhor    hhh,hh5-5-4-.55-    5-5.5-.5-5-.55-.5-.5-5- .5-.6-.5-5-hh}or h{hhh{{{h,horh}or
hhh{{{hhhorhhhorhhhhhh{hhh{{{h,horh}ro{{hhhor                                           hhh,hhhorhhh}or8}or	h}orhhhhhh{hhh{{{h,horh}








or {{hhhorh}orhhhhh{hhh{{{h,horh}orhorhhh,hhhh}orh{hhh{{{h,horh}orh}}}}}}}}}}}}}}}}}}}}}}}}}}}} }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}orh}orhhh{{{hhhorh}orhhhhh{hhh{{{h,horh}orhorhhh,hhhh}orh{hhh{{kh,horh}orhhh{{{hhhorhhh}or8}or	h}orhhh{{{hh}orhorhhh,hhhh}orh{hhh{{{h,horh}orhhhorh}or	h}orhhh{{{hhhorh}orhhhhh{hhh{                                                                       BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB         {{h,horh}orhorhhhhh{hhh{{{h,horh}orhorhhh,hhhh}}or{hhhor                  h{{{h,horhh{hhh{{{h,horh}orhhh{{{hhhorhor{{hhhorhhh,hhhh}or8}or	h}orhhhhhh{h,h{{{h,horh}orhhh{{{hhhorh}orhhhhh{hhh{{{h,horh}orhorhhh,hhhh}or h{hhh{{{h,horh}orhhh{{{hhhor8}or	{hhh{{{h,horh}








orhhh{{{hhhorh}orhhhhh{hhh{{{h,horh}orhhh}or8}or	h}orhhhhhh{hhh{{{h,horh}








or {{hhhorh}orhhhhh{hhh{{{h,horh}orhor-hhh,hhhh}orh{hhh{{{h,horh}or:x(1)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = function (self, a,b) return self.i+a+b end

assert(a.t:x(4,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = senf.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y end
assert(a.b.c.f1(4) == 5)
a.b.c:d2('k', 12); assert(a.b.c.k == 12)

print('+')

t = nil   -- 'declare' t
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)(2,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y e.

print("testing functions and calls")

-- get the opprt(type(asser == 120)
end
assert(fact == false)

-- testing declarations
a = {i = 10}
self = 20
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = function (self, a,b) return self.i+a+b end

assert(a.t:x(2,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y end
assert(a.b.c.f1(4) == 5) 
a.b.c:f2('k', 11);
  end
end

do
  function dummy (n)
              if n > 0 then
                         if n>0 then return deep(n-1) else sert(type(assert) == type(print) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = (a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y end
assert(a.b.c.f1(4) == 5)
a.b.c:f2('k', 12); assert(a.b.c.k == 12)

print('+')

t = nil   -- '  else errassert(a == 120 and b == 3)
print('+')

function err_on_n (n)
  if n==0 then error(); exit(1);
  else err_on_n (n-1); epit(1);
  end
end

do
  function dufact (n)
    if n==0 then return res
    else retu = 20
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)(2,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y20
function a:x (x) return end
function a.y (x) return x+self end

assert(a:x(0)(2,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.(b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y e.

print("testing functions and calls")

-- gting local-functiot (n)
    if n==0 then return res
    else return n*fact(n-1)
    end
  end
  assert(fact(5) == 120)
end
assert(fact == false)

-- testing declarations
a = {i = 10}
self = 20
function a:x (x) return x+self.i end
function a.y (x) return x+self end

asser:(ax1(t)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = f function a:add (x) self.x, a.y = self.x+x,cal a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y end
assert(a.b.c.f1(4) == 5)
a.b.cction (self, a,b) return self.i+a+b end

assert(a.t:x(2,3) == -95)

do
  local a = {x=0}
  function a:a t[4] == 'a')
f(1,2,   -- this one too
ype(f) == 'function')


-- testing local-func...        .S[testing declarations
a = {i = 20}
self = 20
function a:x (x) return x+self.i end
function a.y urn x+self end

assert(a:x(1)+10 == a.ynd
funcal,i