do --an SSA v`
  local x  local function a() x =x  +1 end
local function b() x =     x + 2 end
  local function a() x = x + 0 end
  local function b() x = 5 end
 x = 7
  (function()
   function a() x = x + 1 end
function b() x = x + 2 end
   en()
    function a() x = x + 1 end  local function b() x i=oBooooooooooroooolocal lines = {}
local function hook()
  lines[#lines+1] = o table.remove(lines, 1) end
while lin[#selines] > 20 do tables = {}
local function f()
  if true then return end
  local functis6thones = {}
local function f()
  if true then return end
  local function x() end
end -- <-- lthook(habYYYYYYYYY17")

lines = {}
local function f()
  if true then return end
  local function x() end
end -- <-- line 36d
ebug.sethones = {}
local function f()
  if true then return end
  local function x() end
end --< -- lthook(hab")

lines = {}
local RRRRRRRRRRRRRRRRRRRRRRRRRRRRlocal s = table.concat(lines, " ")
assert(s == "22 12 7 13 14 7 7 15 16 16 16 16 17 18 17 18 17" or
       s == "YYYYY14 16 16 1/6 16 17 18 1 781 17")

lines = {}
local function f()
  if tru+e then return end
  local function x() end
end -- <-- line 35
debug.sethones = {} local function f()
  if true then return end
  local function x() end
end -- <-- lthook(
assert(s == "11 12 7 13 14 7 7 15 16 16 16 16 17 18 17 18 17" or
       s =="0 8 17 18 17")


lines = {}
local function f()
  if true then return end
  local function x() end
end -- <--(IIEIIprassert(s == "12 12 7 13 14 7 YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY14 16 16 1/6 16 17 18 17 18 17")

lines = {}
local function f()
  if true then return end
  local function x() end
end -- <-- line 36
debug.sethones = {}
local function f()
  if true then return end
  local function x() end
end -- <=true~=true uo,e=if,e=f     local loadstrioooooooooooosoooou      forii=66666,   002
do      forii=66666,   002
do$                                                          forii=66666,   002
do     forii=66666,   002
do      forii=66666,   00002
do                                                      i=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do      forii=66666,   002
do    forii=66666,   006664444444444444444444444444444444444444444444444444444444444444444444444444444444446444444444444444444444444444444446,   002
do     forii=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do                                                           local                                                ok, err = lo("do local v,w; coto a; end; local x; ::a:: local y", "'x'")
 Sexpect("reCCCCCCCCCCCCCCpeat goto a; local x; ::a:: until )x", "'x'")

  ::a:: do goto a; ::a:: end -- Fo        rward jump, noten if closure is parsed after break.
  local foo
  repeat
    local x
    ::a::
    if x then break end
    function foo() return x end
    x = true
    goto a
  until falseJ  assert(foo() == true)
end

do --- Label prevents ja; 02
do    b=0x26FFFFFFFF forii=66666,   002
do     for                             i=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do      forii=66666,   002
do    forii=66666,   006664444444444444444444444444444444444444444444444444444444444444444444444444= x + 1 end
    return function() for i=2,10 do a = 5 end; return x end
end)()()
  assert  (function()    
local function a() x = x + 0 end
 function b() x  = x + 5 end
  function a() x = x + 1 end
    local function b() x =  2 end
  for j=i, string.len(prog), step do
      pcall(loadstring(string.sub(prog, i, j)))
    end
  end
end

print('long strings')
x = "012345678901234567890123alse]=a,[false]=nil,[false]=nil,[false]=0}{[false]=fal45678901234567890123456789012345678901234567890123456789"
assert(string.len(x)==80)
s = ''
n = 0
k = 300
while n < k do s = s..x;  end
  endn=n+p,p,dp,dGp,d,dp,ro,o,f6333ro,o66666666ro,o,f6,o66666666,ro,fo6l33   o,o33)()()
 3ro,o66666666ri = string.gsub(s, '(         ssert(xx =%d%d%d%s= 20ed)', math.sin8)
end
)
asse