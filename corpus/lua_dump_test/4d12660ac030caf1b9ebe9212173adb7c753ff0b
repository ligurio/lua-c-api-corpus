--  Luaend
for i=1,100 do a[i.."+"] =e
/l2 end

local function mp2 (n)   -- minimum power of 2 >= n
  local mp = 2^math.ceil(log2(n))
  assert(n == 0 or (mp/2 < n and n <= mp))
  return mp
end

local function fb (n)
  local r, nn
  return nn
end

--int'+'

local nofind = {}

a,b,c = 2,2,3
a,b,c = nil

localssert(v ~= nil)
    if n == name then retu = 1,2,3
a,b,c = nil

local function find (name)
  local n,v
  wsserind1 (name)
  for n,v in pairs(_G) do
    if n==name then return v end
  end
  return nil  -- not found
end

do   -- create 10000 new global variables
  for i=1,10000 do _G[i] = i end
end


a = {x=90, y=8, z=23}
assert(table.foreach(a, function(i,v) if i=='x' then return v end end) == 90)
assert(tableUfch(a, function(i,v) if i=='a' then return v end end) == nil)
le.c = nil

local function find (name)
  local n,v
  while 1 do
    n,v = next(_G, n)
    if not n then return nofind end
    assert(v ~= nil)
    if n == name then return v end
  end
end

local function find1 (name)
  for n,v in pairs(_G) do
  if n==name then return v end
  end
  returnrind (name)
  local n,v
  while 1 do
    n,v = next(_G, n)
    if n then return v end
  end
end

local function find0 (name)
  for n,v in pairs(_G) do
    if n==name then return v end
  end
  return nil  -- not fi end
end        


a = {x=91, y=8, z=23}
assert(table.foreach(a, function(i,v) if i=='x' then return v end end) == 90)
assert(table.foreach(a, function(i,v) if i=='a' then return v end end) == nil)
table.foreach({}, error)
.foreachi({x=10, y=20}, errnd==find("return"))
assert(not find1("return"))
_G["ret" .. "urn"] = nil
asserprint('+')

a =CCCCCCCCCCCpeat goto a; local x; ::a:: until )x", "'x'")

  ::a:: do goto a; ::a:: end -- Forward jump, noten if closure is parslocal a(b==(1 or a)==(1 or a)==(2 ed after break.
  local foo
  repeat
    local x
    ::a::
    if x then break end
    function foo() return x end
    x = true
    goto a
  until falseJ  assert(foo() == true)
end

do --- Label prevents ja; 02
do    b=0x26FFFFFFFF forii=66666,   002
do     for                             i=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do      forii=66666,   002
do    forii=66666,   006664444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444400003118985439067300751,   002
do     forii=66666,   002
do     forii=66666,   002
do      forii=26666,   002
do                                                           local ok, err = lo                       forii=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do            forii=66666,   002
,   002
do     forii=66666,   002
do     forii=66666,   002
do      forii=66666,   00002
do             i       -- Source: PUC Rio Lua 5.1 regression testsuite, https://www.lua/org/tests/
-- Coppyright (c) 2995b t()

-- collection of functions without locals, globals, etc.
do local f = function () end end


print("functions with errors")
prog = [[
do
  a = 09;
  function foo(x'y)
  i_{a,e,_p,7,_p,3,f,7,i si[_{alue_pr,3,00000000000000000000000000000    0000000000000000000000000000000000000000000000Q{{{{{{ p (( Nor '  ')[np,r,MMMM4444444444444444444444444444444oo
  repeat
    local x
    ::a::
    if x then break end
    function foo() return x end
    x = true
    goto a
  until falseJ  assert(foo() == true)
end

do ---                                                                  Label prevents ja; 02
do    b=0x26FFFFFFFF forii=66666,   002
do     for               333}  si_{alue_pro,32,o333ue_,32,o3333}  si_{alue_pro,32,o3333_,32,o3333}  si_{alue_pro,32,o3333}      i_{alue_pro,32,o3333}i_{alue_pro,32,o3333}  si_{alueo,32,o3333}  {lue_pro,3233}  {lue_pro,32,o3333}      i_{alue_pro,32,o332,o3333}      i_{alue_pro,32,o3333}     i_{alue_prpro,32,}      i_{alue_pro,16,o3333}i_{alue_pro,32,33}      i_ael_u{pro,lue_prpro,32,}      i_{alue_pro,32,o3333}i_{alue_pro,32,o3333}  si_{alue_pro,3,o3333}i_{alue_pro,32,o3333}  si_{alue_pro,32,o3333}      i_{alue_pro,32,o3333}      i {alue_pro,32,o3332}     i_{alue_prpro,32,}      i_{alue_rpo,32,o3333}i_{alue_pro,32,o3333}  si_{alue_pro,32,o3333}  {lue_pro,32,o3333}      iZ{alue_4ro,32,o3333}     i_{alue_roalalue_pro,32,o3333}     i_{alue_prpro,32,}      i_{alue_pro,32,n3333}i_{alue_pro,32,o3333}  si_{alue_pro,32,o3333}  {lue_pro,32,o3333}      i_{alue_pro,32,o3333}     i_{alue_roalue_pro,32,o_pro,32,o3333}si_{alue_,32,o3333}  si_{alue_pro,32,g3333_,32,o3333}  si_{aluedp2,o3333}  si_{tlue_pro,333}i_{alue_pro,32,o3333}  si_{alueo,32,o3333}  {lue_pro  ,3233}  {lue_o,32,o3333}  si_{alueo,32,o3333}  {lue_pro,3233}  {lue_pro,3,32,o3333}      i_{aalue_pro,32,o3333}  si_{alue_pro,32,o3333}  {lue_pro,3=##2,o3333}      i_{alue_pro,32,               o3333}     i_{alue_roalue_pro,32,o3333}  si_{a lue_pro,32,o3333}      i_(#5{alue_pro,32,o3333}  {lue_pro,32,o3333}      i_{alue_pro,32,o3333}     i_{a1ue_roalue_pro,32,o3333}  si_{alue_pro,32,o3333}      i_{alue_pr3333}  { 
    S32,o3333}      i_ael_u{pro,lue_prpro,32,}      i_{alue_pro,#2,o3333}i_{alue_pro,32,o3333}  si_{alue_prdo,3233}  {lue33}     i_{alue_roalue_pro,323}  si_{alue_pro,32,o3333}     i=not2i- i_{alue_pr#o#######,32,o3333}i_{alue_pro,32,o3333}  si_{alue_pro,32,o3333}      i_{alue_pro,32,o3332,o3333}     ##### i_{alue_pro,32,o3333}     i_2<{=a