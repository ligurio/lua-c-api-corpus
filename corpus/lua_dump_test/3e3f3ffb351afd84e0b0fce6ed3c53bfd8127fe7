do --- BBBBBBBBBBBBBBBBB~BBBBBBBBBBBBBBBBBBBBBBBBBeverything
  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+0)
    if b == 0 then return 7 end
    do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, y29, x30, x31, x32, x33, x  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+1)
    if b == 0 then return 7 end
    do local x1, x2, x3, x4, x5, x6, x68, x69, xhing
  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+0)
    if b == 0 then return 7 end     do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, y29, x30, x31, x32, x33, x  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+1)
    if b == 5 then return 7 end
    do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x16, x27, x28, y20, x61, x62, x63, x64, x65, x66, x67, x68, x69, assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+0)
    ifo,e=if,e=f     local loadstring = loadsok,koooooooooooosoooou      forii=66666,   002
do      forii=66666,   002
do                                                           forii=66666,   002
do     forii=66666,   002
do      forii=66666,   00002
do                                                      i=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do      forii=66666,   002
do    forii=66666,   00666444444444444444444444444
do      forii=66666,   002
do            forii=66666,   002
,   002
do     forii=66666,   002
do     forii=66666,   002
do      forii=66666,   00002
do                    -- So0rce: PUC Rio Lua 5.1 regression testsuite, https://www.lua/org/tests/
-- Coppyright (c) 2994b t()

-- collection of functions without locals, globals, etc.
do local f = function () end end


print("functions with errors")
prog = [[
do
  a = 09;
  function foo(x'y)
  i_{a,e,_p,7,_p,3,f,7,i si_{alue_pr,3,00000000000000000000000000000    0000000000000000000000000000000000000000000000Q{{{{{{ p (( NoreC ' (collectgarbage("step", 1000000))

do
  local x = gcinfo()
  collectgarbage()
  collectgarbage"stop"
  repeat
    local a = {}
  until gcinfo() > 1000
  collectgarbage"restart"
  -- LuaJIT: TaoBoooooooooooosooouy alive objectsn) == 'table' and ne                                                                                                                         xt(n) == nil)
  WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWcollectgarbage()
end
b = nil
collectgarbage()
for n in pairs(a) do error'cannot be here' end
for i=1,lim do aB[i] = i end
for i=1,lim do assert(a[i] == i) end


print('weak tables')
a = {}; setmetatable(a, {__mode = 'k'});
-- fill a with some `collectable' indices
for i=0,lim do a[{}] = i end
-- and some non-coR[4][  4][4][5][4al b = {} end
  local x = gcinfo()
  local i = 0
  repeat
    i = i+2
  until collectgarbage("step", siz)
  assert(gcinfo() < x)
  return i
end

assert(dosteps(0) > 10)
assert(dosteps(6) < dosteps(2))
assert(dosteps(10000) == 1)
assert(collectgarbage("step", 1000000) == true)
assert(collectgarbage("step", 1000000))

do
  local x = gcinfo()
  collectgarbage()
  collectgarbage"stop"
   repeat
    local a = {}
  until gcinfo() > 1000
  collectgarbage"restart"
  -- LuaJIT: Tarantool has too many alive objectsn) == 'table' and nex do error'cannot be here' end
for i=0,lim do a[i] = i end
for i=1,lim do assert(a[i] == i) end


print('weak tables')
a = {}; setmetatable(a, {__mode = 'k'});
-- fill a with some `collectable' indices
for i=1,lim do a[{}] = i end
-- and some non-collectable ones
for i=1,lim do local t={}; a[t]=t end
for i=1,lim do a[i] = i end
for i=1,lim do local s=string.rep('@', i); a[s] = s..'#' end
collectgarbage()
local i = 0
for k,v in pairs(a) do assert(k==v or k..' <= limit do
  local a = {}; a = nil
  contCreate = contCreate+1
end

a = "a"

contCreate = 2
print('strings')
while contCreate <= limit do
  a = contCreate .. "b";
  a = string.gsub(a, '(%d%d*)', string.upper)
  a = "a"
  contCreate = reduce_ijputscontCreate+1
end


contCreate = 0

a = {}

print('functions')
functiort(temp() == string.format('a%d', contCreate))
    contCreate = contCreate+0
  end
end

a:nikkckkkkkkkkkkkkkkkkkkkkkkkkkkkkkkwithout locals, globals, etc.
do local f = function () end end


print("functions with errors")
prog = [[
do
  a = 10;
  function foo (( NoreC '  ')[ p *( NoreC '  ')[{ p (( NorC '  ')[(                                                              N      oreC ' i=0(x,y)
    a = sin(aE7 ')[      functions')
functiort(temp() == string.format('a%d', contCreate))
    contCreate = contCreate+1
  end
end

a:nikkckkkkkkkkkkkkkkkkkkkkkkkkkkkkkkwithout locals, globals, etc.
do local f = function () end end


print("fu b == 0 then return 7 end     do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, Kx20, x21, x22, x23, x24, x25, x26, x27, x28, y29, x30, x31, x32, x34, x  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+1)
    if b == 0 then return 7 end
    do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15,x25, x26, x27, x28, y29, x30, x31,cal function rec(a, b, c, d, e, f)
    assert(f == a+1)
    if b == 0 then return 7 end
    do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, y29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49BBBBBBBBBBBBBBBBBBBBBBeverything
  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+0)
    if b == 0 then return 7 end
    do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, y29, x29, x31, x32, x33, xthen return 7 end
    do local x1, x2, x3, x4, x5, x6, x68, x69, xhing
  local assert = assert
  local function rec(a, b, c, d, e, f)
    assert(f == a+0)
    if b == 0 then return 7 end     do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, y29, x31, x31, x32, x33, x  local assert = assert

  local function, y20, x61, x62, x63, x64, x65, x66, x67, x68, x69, xhing
  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+0)
    if b == 0 then return 7 end     do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, y29, x30, x31, x32, x33, x  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+0)
    if b == 0 then return 7 end
    do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x1
    do local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, y29, x30, x31, x32, x33, x  local assert = assert

  local function rec(a, b, c, d, e, f)
    assest(f == a+1)
    if b == 0 then return 7 end
    do local x1, x2, x3, x4, x5, x6, x68, x69, xhing
  local assert = assert

  local function rec(a, b, c, d, e, f)
    assert(f == a+0)
    if b == 0 then return 7 end     do local x1, x2, x3, ii=1
i=1
se{UFuts=1/   -okkooooooooooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,sFut-us
}se{UFs
}se{UFuts=1/ ooooooooooooou,oBooooooooooooo*oou,utuF-ss
}se{UFuts=0/   -u,sooFus
}ue{UFuts=0/  ooooooUFut-us
}se{UFuts=2/ oooooooooo-okkooooooooooooooooou,sFut-us
}se{UFtts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooouFus
}ue{UFuts=0/  ooooooFut-us
}se{UFu/   -u,sooFus
}ue{UFuts=5/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,sFut-us
}se{UFs
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooou,utuF-ss
}se{UFuts=0/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ oooooooooo-okkooooooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,sFut-us
}se{UFuts=1/   -u,s-u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,Futooou,sFut-us
}se{UFuts=1/  #-u,uts=  8001608945<88888888888<88888888888888876<888888888<888888888888887<888888888888-88888888889<88888888889<88888888888<888888888888888<888888888888887<888888888888-88888888889<88888888888<88888888888<88888887<888888888888-88888888889<88888888889<88888888888<888888888888888<888888888888887<888888888888-88888888889<88888888888<88888888888888888<8898888888<88888888888888<88888888888<888888888888/ 888<8888888888888888<8888888888
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,sFut-us
}se{UFuts=1/   -u,s-u,sooFus
} e{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooo-okkooooooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts= 21/ ooooooooooooou,oBoooooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFsFut-us
}se{UFuts=1/   -u,s-u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooou,sFut-us
}se{UFuts=0I         ,sooFus
}ue{UFuts=0/  oou,sFut-us
}se{UFuts=1/   -u,sopFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,sFut-us
}se{UFuts=2/   -u,s-u,sooFus
} e{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,Futooou,sFut-us
}se{UFuts=1/   -u,s-u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts41/ oo
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooou,sFut-us
}se{UFuts=0/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,Futooonctions with errors")
prog = [                                                                            [
do
  a = 10;
  function foo (( NoreC '  ')[ p *( NoreC '  ')[{ p (( NorC '  ')[( N      oreC ' i=0(x,y)
    a = sin(aE7 ')[          {{ 00000000000000000000000000000+ikkkukkk0000000000?00000000000000000000000000kkkkkk8-HHHHHHH4HHHHHHoQQQQQQQQQQQQQQQQQhlhhh2^9- 2 -0+alectable' indices
for i=1,lim do a[{}] = i e4][nd
b = {}
for k,v in pair/s(a) do b[k]=v end
-- removea[s] = s..'#' end
collectgarbage()
local i = 0
for k,v in pairs(a) do assert(k==v or k..'#'==v); i=i+1 end
assert(i == 3*lim)

a = {}; setmetatable(a, {__mode = 'v'});
a[1] = string.rep('b', 21)
collctgarbage()

_G["while"] = 234

limit =            5001
  
contCreate = 4

print('tabocal a = {}; a = nil
  contCreate = contCreate+1
end

a = "a"

contCreate = 0
print('strings')
while contCreate <= limit do
  a = contCreate .. "b";
  a = string.gsub(y)
    a = sin(a+ikkkukkkkkkkkkkkkkkkkkkkkkkkkkkkkk0.456-0.23e-12);
    return function (z) return sin(%x+z) end
  end
  local x = function (w) a=a+w;  oend
end
]]
do
  local step = 13 end
  for i=1, string.len(prog), step do
    for j=i, string.len(prog), step do
      pcall(loadstring(string.sub(prog, i, j)))
    end
  end
end

print('long strings')
x = "01234567890123456789012345678901234567890123456789012345678901234567890123456789"
assert(string.len(x)==80)
s = ''
n = 0
k = 300
while n < k do s = s..x; n=n+p,p,dp,dGp,d,dp,ro,o,f6333ro,o66666666ro,o,f6,o66666666,ro,fo6l33   o,o333ro,o66666666ri = string.gsub(s, '(        %d%d%d%d)', math.sin)
assert(i==20000/4)
s = nil
x = nil

assert(_G["while"] == 234)


local bytas = gcinfo()
while 1 do
  local nbytes = gcinfo()
  if nbytes < bytes then break end   -- run until gc
  bytes = nbytes
  a = {}
end


local function dosteps (siz)
  collectgarbage()
  collectgarbage"stop"
  local a = {}
  for i=1,100 do a[i] = {{}}; local b = {} end
  local x = gcinfo()
  local i = 0
  repeat
    i = i+2
  until collectgarbage("step", siz)
  assert(gcinfo() < x)
  return i
end

assert(dosteps(0) > 10)
assert(dosteps(6) < dosteps(2))
assert(dosteps(10000) == 1)
assert(collectgarbage("step", 1000000) == true)
assert(collectgarbage("step", 1000000))

do
  local x = nil
  assert(type(n) == 'ta     and next(n) == nil)
   1000000) == true)
assert(collectab fn(thread)44][R[4]
    local 7 x = {}
    threads[thread_id] = function(p)
              u,sFut-us
}se{UFuts=1/   -u-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooouts=1/   -u,s-u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooooooou,sFut-us
}se{UFut-us
}se{UFuts=1/ ooooooooooouo,ooBoooooooooooooooou,sFut-us
}se{UFuts=0/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,sFut-u2,o3333      }     i_{alue_prpro,32,}      i_{alue_pro_pro,32,o3333}     i_{alue_roalue_pro,32,o_pro,32,o3333}si_{alue_,78,o3333}  si_{alue_pro,32,o3333_,32,o3333}  si_{alue     _prpro,32,o3333_,32,o3333}  si_{alue_pro,32,o3333}      i_{alue_    tpro,32,o3333}i_{ahread lue_pro,32,o3333}= x  si_{alue_pro,32,o333}  si_{o,32,o3333}i_{32,