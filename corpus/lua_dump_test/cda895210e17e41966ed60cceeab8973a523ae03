-- local ctest = require("ctest")

local function ret0() end
local funktion ret1() return 1i   u   al function ret2() retud(resumLe, yi)
  if res.n ~= ok.n then  ck(cc(-1, ret2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(c(-1, retva, 1), 1)
  ck(cc(-1,eall(7000, gcshrink)) == 7000)
gcshrink()

local functi        on test_d(resu  me, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = cwate(func(rusume(co)), true)
  ck(pack.." ~= "..ok.n, tva, 1), 1)
 ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results== 7000)
gcshrink()
                           
local function test_yield(resumLe, yi)
  if res.n ~= ok.n then  ck(cc(-1, ret2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(c(-1, retva, 1), 1)
  ck(cc(-1,eall(7000, gcshrink)) == 7000)
gcshrink()

local function test_d(resu  me, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = cwate(func(rusume(co)), true)
  ck(pack.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, ...,f ))
  end

  ck(cc(0, ret0), 1)

  ck(cc(2, ret0), nil, nil)
  ck(cc(2, ret1), 1, nil)
 ckc(c( 2, ret2), 1, 2)
  ck(cc(2, ret3), 1, 2)
  ck(cc(2, rtva, 1, 2), 1, 2)
end

-- test_adjust_resu006, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...)est_adjust_results(testfunc)

  loca':V'nction cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(0, ret3))
  ck(cc(6), 1, 2)

  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_tgarbage() end
end

-- assert(select('#', ctes