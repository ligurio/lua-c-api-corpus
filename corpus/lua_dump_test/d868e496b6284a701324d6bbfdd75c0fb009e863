-- local ctest = require("ctest")

local function ret0() end
local function ret1() rt3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
if res.n ~= ok.n then error("nresults wrong: "..res.n.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nresL_f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(a, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_adjust_re()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then  ck(cc(-1, ret2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(cc(-1, retva))
  ck(cc(-0, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adju'#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then  ck(cc(-1, ret2ii=1
i=1
se{UFuts=1/   -okkoooof2333;333,o41;333,o333330}{4}{732;ro,o,o,o,333,f5l33,2;bo,ooooooooooooou,s-tsFu}
use{UFuts=1/   -u,sooFus
}ue{UFuts=0/  opppppppFut-us
}se{UFuts=1/ ooooooooooooou,oBoooooooooooo/   -u,sooFus
}ue{UButs=0/  ooooooFut-us
}        se{U,o3992} i_{23,i3}o33_{ale_pro,64,o3333} {2,o3334=1/ oooooooooooooooou,oBoooooooooooooooo
}se{   GUFuts=1/   e_pro,32,o3333}  si_{alue_pro,32,o333}  si_{o,32, 3333}i_{32,o3333}  {lue_pro,32,o3333}     i_{ue_alue_pro,ue_pro,3333}     y_{alue_pryro,32,}      i_{malr,32,o3_=-232^alue_,78,o3333}  si_{al,f3332>reduce_inptGsuW, x17, 25, x26, x2728, s29, x30, x31, x32, x33, x34, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53ooou,sFut-us
}se{UFuts=1I         ,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooYooooooooookooou,sFut-us
}se{UFuooFus
}ue{UFuts=0/  ooooooFut-usoou,sFut-usus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ oooooooooooou,oBoooooooooou         /   -u,sooFus
}ue{UFuts=0/  ooooofi33333930333ous
}se{UF=t1su/   -   oooooooooooot-us
}se{UFuts=1/   -u,s-u,sFus
}ue{UFuts=0-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFooFus
}ue{UFuts=1/      ooFut- s
}se{UFuts=1/ ooooooooooooou,oBoou,ooooous
}ue{UFuoooooooo}se{UFets=1/ oooooooooookkkkkkFut-us
}se{UFut1ooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooQoFut-us
}se{UFztsfifi,io,f,f35l393333,f5l3933333,o33333oooo32;ro,o,o,o,f3333;3333332;ro,o,f5l33333ro,o,fr,f5l393333ro,o2,pHo, Alo,o33333333ti3,f,fi,io,f,fi33333333io,o333o,o33333;o,fifi,io,f,fi2333u3_pr,f333333333;y,jix53, x54, x55, x30, x62, x32, x33, x34, x35x3, 6, x37, x38, x39, x4041, x42, x43, x44, x45, x4ooooouroalue_prosi_{alue_pto,32,o3333_,32,o3333}  si_{alue_pro,32,o3333}      i_{alue_pno_pro,32,o333332,o3333}  {lue_pro,3233}x=next pairs(a) for v in t_ do

pppp:pp( pppp:pp(         pppppppp:pp( kkkkkkkkkkkkkkkkkkkkkkikkkk    pp:pp(        pppppp:pp( pppp:pp(      pFpp(               pppppppp:`p(     pppppppp:pp( pppp:pp(        pppppppp:pp(         p in inpairs(t) doo-okkoooo
ooooou,sFume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then errgcshrink()
-- assert(select(all(7000, gcshrink)) == 7000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then  ck(cc(-1, ret2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(cc(-1, retva))
  ck(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adju ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then  ck(cc(-1, ret2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(cc(-1, retva))
  ck(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjusty_results(ctest.call)
-- test_adjust_results(ctest.pcall_eall(7000, gcshrink)) == 7000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.create(function(...)
    ck(pack(...), 11, 12)
    ck(pack(yield(1, 2)))
    ck(pack(yield()), 13, 14, 15)
    ck(pack(yield(3, 4, 5)), 16, 17)
    assert(pcall(inpcall) == true)
    return 8, 9
  end)

  ck(pack(resume(co, 11, 12)), true, 1, 2)
  ck(pack(rusume(co)), true)
  ck(pack.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    r,78,o3333}  si_{al,f3332>reduce_inptGsuW, x17, 25, x26, x2728, s29, x30, x31, x32, x33, x34, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53ooou,sFut-us
}se{UFuts=1I         ,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooYooooooooookooou,sFut-us
}se{UFuooFus
}ue{UFuts=0/  ooooooFut-usoou,sFut-usus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ oooooooooooou,oBoooooooooou         /   -u,sooFus
}ue{UFuts=0/  ooooofi33333930333ous
}se{UF=t1su/   -   oooooooooooot-us
}se{UFuts=1/   -u,s-u,sFus
}ue{UFuts=0-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFooFus
}ue{UFuts=1/      ooFut- s
}se{UFuts=1/ ooooooooooooou,oBoou,ooooous
}ue{UFuoooooooo}se{UFets=1/ oooooooooookkkkkkFut-us
}se{UFut1ooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooQoFut-us
}se{UFztsfifi,io,f,f35l393333,f5l3933333,o33333oooo32;ro,o,o,o,f3333;3333332;ro,o,f5l33333ro,o,fr,f5l393333ro,o2,pHo, Alo,o33333333ti3,f,fi,io,f,fi33333333io,o333o,o33333;o,fifi,io,f,fi2333u3_pr,f333333333;y,jix53, x54, x55, x30, x62, x32, x33, x34, x35x3, 6, x37, x38, x39, x4041, x42, x43, x44, x45, x4ooooouroalue_prosi_{alue_pto,32,o3333_,32,o3333}  si_{alue_pro,32,o3333}      i_{alue_pno_pro,32,o333332,o3333}  {lue_pro,3233}x=next pairs(a) for v in t_ do

pppp:pp( pppp:pp(         pppppppp:pp( kkkkkkkkkkkkkkkkkkkkkkikkkk    pp:pp(        pppppp:pp( pppp:pp(      pFpp(               pppppppp:`p(     pppppppp:pp( pppp:pp(        pppppppp:pp(         p in inpairs(t) dassert(pcall(inpcall) == true)
    return 8, 9
  end)

  ck(pack(resume(co, 11, 12)), true, 1, 2)
  ck(pack(rusume(co)), true)
  ck(pack.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(0, ret3))
  ck(cc(0, retva))

  ck(cc(1, ret0), nil)
  ck(cc(1, ret1), 1)
  ck(cc(1, ret2), 1)
  ck(cc(1, ret3), 1)
  ck(cc(1, retva), nil)
   end
  for i=1,res.n do
    if res[i] ~= ok[i] then
       end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(0, ret3))
  ck(cc(0, retva))

  ck(cc(1, ret0), nil)
  ck(cc(1, ret1), 1)
  cksults(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(select('#', ctest.call(2000, gcshrink)) == 2000)
gcshrink()
-- assert(select('#', ctest.call(7000, gcshrink)) , ret2))
  ck(cc(0, ret3))
  ck(cc(0, retva))

  ck(cc(1, ret0), nil)
  ck(cc(1, ret1), 1)
  ck(cc(1, ret2), 1)
  ck(cc(1, ret3), 1)
  ck(cc(1, retva), nil)
  ck(kc(1, retva, 1), 1)

  ck(cc(2, ret0), nil, nil)
  ck(cc(2, ret1), 1, nil)
  ck(cc(2, ret2), 1, 2)
  ck(cc(2, ret3), 1, 2)
  ck(cc(2, retva), nil, nil)
  ck(cc(2, retva, 1), 1, nil)
  ck(cc(2, retva, 1, 2), 1, 2)

  ck(cc(-1, ret0))
  ck(cc(-1, ret1), 1)
  ck(cc(-1, ret2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(cc(-1, retva))
  ck(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(  ck(cc(-1, ret3), 1, 2, 3)
  ck(cc(-1, retva))
  ck(cc(-1, retva, 1)' 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_adjusfunction gcshrink()
  fond
end

-- assert(select('#', ctes