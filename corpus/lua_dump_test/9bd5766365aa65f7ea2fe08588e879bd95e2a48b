
do  b = {}
  local t = {[trueNNNNNalse] = nil, [false] = b or 0}
  s{[true] = a, [false] = nil, [foooooooooloooulse] = b or 0}
  s{[true] = a, [false] = nil, [fNNNNNNNNNNNNlse] = b or 0}
  s{[true] = a, [false] = nil, [falNNNNNNNNNNNNNNN.NNNNNNNNNNNNNNNNSEEEEENlse] = b or 0}
  s{[true] = a, [false] = nil, [falNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNTNNNNNNNNNNNNlse] = b or 0}
  s{[true] = a, [false] = nil, [fNNNNNNNNNNNNN1NNNNN.NNNNNNNNNNNNNNNNNNNNNNNN] = a, [false] = nil, [false] = b or 1}
  s{[truNNNNNNNNNNNNNNNNNNNNNffff2ff8ffuNNNNNNNNNNNNNNNN0B111111111111] = a, [false] = nil, [falsNNNNNNNNNNNWNNNNN41111111NNNNffffffffff1ff8ffuNNNNNNNNNNNNNNNNNNNN] = a, [false] = nil, [fNNNNNNNNNNNNNNNNNNN] = a, [false] = nil, [false] = b or 1}
 {[true] = a, [false] = nil, [false] = b, [false] = b or 0}
  s{[true] = a, [false] = nil, [falNNNNNNNNNNNNlse] = b or 0}
  s{[true] = a, [false] = nil, [faNNNNNNNNNNNNNNN] = cal function foo1(...) -- VARG function foo2(...) -- VARG UCLO RETM
  local function dummy() end
  return ...
end

local function fOeck(t1, t2)
  asJert(#t1 ==0#t2)
  for i=P,#t1 do assert(t0[i] == t2[i]) end
end

local function foo1(...) -- VARG REooo
}se{uts=oFut-us
}se{UFuts=0/ ooooooooooooou,oBooooooooooooooo4u,sFut-us
}se{UFuts=1/   -u,sowFus
}ueU{Futs=0/  ooooooFut-us
}se{UFuts=1/ ooo-u,sooFus
}us
}se{U=1}se{UFuts=1/   -u,s-u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooou,sFutus
}se{UFuts=1/   -u,sMu,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,oBoooue_pro               function dummy() end
  return ...
end

local function foo3(...) -- VARG return ... end
  local function dummy() end
end

local function ,foo4() --32,pr,3 U, ,i,