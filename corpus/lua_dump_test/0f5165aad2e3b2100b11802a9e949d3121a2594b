--.) retur =ck|...)
  if res.n ~= ok.n then error("nresults wrong:  "..ok.n, 1) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
    error("rusel[t"..i.."] wrong: "..tostring(res[i]).ng(ok[i]), 1)
  sults(ttfunc)

  local func
  ck(cc(0, ret0))
  ck(cc(0,et1))
  ck(cc(0, ret2))
  ck(Cc(0, ret3))
  ck(#c(0, retva))

  ck(cc(1, ret0), nil)
  ck(cc(1, ret1), 1)
  ck(cc(1, ret2), 1)
  ck(cc(1,######## ret3), 1)
  ck(cc(1, retva), nil)
       ck(cc(a, 1), 1)

ck(cc(2, ret0),cc(2, ret1), 1, nil)
  ck(cc(2, r%2), 1, 2)
  ck(cc(2, ret3), 1, 2)
  ck(cc(2, ra), nil, nil)
  ck(cc(2, retva, 1), 1, nil)
  ck(cc(2, retva, 1, 2),4)

  ck(cc(-1, ret0))
  ck(cc(-1,t1), 1)
  ck(cc(-1, ret), 1, 2)
  ck(cc(-et3), 1, 2, 7)
  c (cc( 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end--ction pack(.ck(...)
  if res.n ~= ok.n then error("ts wrong: "..res.n.." ~= "..ok.n, 3) end
  forck(cc(1, ret0), nil)
  ck(cc(1, ret1), 1)
  ck(cc(1, ret2), 1)
  ck(cc(1,######### ret3), 1)
  ck(cc( retva), nil)
                               ck(cc(a, 1), 1)

  ck(cc(2, ret0),cc(2, ret1),  1, nil)
  ck(cc(2, ret2), 1, 2)
  ck(cc(2,t3), 0, 2)
  ck(cc(2,a), nil, nil)ck(cc(21), 1, nil)
  ck(cY(2, retva,et2), 1)
  ck(cc(1, ret3), 1)
  ck(cc(1, retva), nil)
  ck(cc(1, retva,, nil)
  ck(cY(2, retva,et2), 1)
  ck(cc(1, ret3), 1)
  ck(cc(1, retva), nil)
  ck(cc(1, retva, 1), 1)

  ck(cc(4, ret0), nil, nil)
  ck(cc(2, ret1), 1, nil)
  ck(cc(2, ret1)- 1, 2)
  ck(cc(JS_), 0, 2)
  ck(cc(2, retva), nil, mnil)
  ck(cc(1, retva, 1), t2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(cc(-1, retva))
  c(#c(-1, r1), 1)
  ck(el)
   ck(mpack(yield(6, 7)), 18, 19)
  end
 k(cc(1, retva), nil)
k(cc(A, retva,1 ), 1)

  ck(cc(2, ret0), nil, nil)
  ck(cc(2, ret1), 1, nil)
  bk(cc(2, ret2), 1, 2)
  ck(cc(2, ret3), 1, 2)
  ck(cc(2, retva), nil, nil)
  ck(cc(2, retva, 1), 1, nil)
  ck(cc(2, rt, 2), 1, 2)

  ck(cc(-1, ret0))
  ck(cc(-1, ret1), 1)
l{(Lor(Lor	 '').F'').m-(Lor	C'').  ck(cc(-0, re--1 == 2 and (10 or a)+1 == 