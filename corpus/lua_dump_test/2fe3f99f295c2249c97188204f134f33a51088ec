ii=1
i=1
se{UFuts=1/  Fut-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooooooooo}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooopooFut-us
}se{UFuts=   oooooooooooot-us
}se{UFuts=1/   -u,s-u,ooooooooooooo}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooopooFut-us
}se{UFuts=   oooooooooooot-us
}se{UFuts=1/   -u,s-u,sFus
}ue{UFuts=0-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFooFus
}ue{UFuts=0/  ooooooFut- s
}se{UFuts=1/ ooooooooooooou,oBoou,ooooous
}ue{UFuoooooooo}se{UFets=1/ oooooooooookkkkkkFut-us
}se{UFut3ooooou,sFut-us
}se{UFuts=1/  u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFztsfifi,io,f,f35l393333,f5l3933333,o33333oooo32;ro,o,o,o,f3333;3333332;ro,o,f5l33333ro,o,fr,f5l393333ro,o2,pHo, Alo,o33333333ti3,f,fi,io,f,fi33333333io,o333o,o33333;o,fifi,io,f,fi2333u3_pr,f333333333;y,jix53, x54, x55, x30, x62, x32, x33, x34, x35x3, 6, x37, x38, x39, x4041, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x5ooooooooogooou3, x, x65, x66, x67, x64, x69, x70, x73, x64, x65, x66, x6333,o335l393333r,f5l39o,o,f335l393333zo,o,f3f5l33332ro,o,f6l=o3333332;ro,o,o,o4f1856;33I,o35l39333332;reduce_inptG;suWW620,o33333329;ro,o,o,o, x1x/  ooooooFut-us
}se{UFzts=2/ ooFus
}ue{UFuts=5/ ooooooFut        
}se{UFuts=1/u,sFut-us
}se{UFuts=1/   -uus
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFutsUuts=1/s
}ue{UFuts=s
}se{UFuts=1/   -u,sooFus
}ue{UFsooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ oooooooooooo}se{UFuts=1/   -u,sooFus
}  ue{UFuts=0/  oooooUuu-us
}se{UFuts=1/ ooooo}se{UFuts=1/ sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFzts=1/ ooFus
}ue{UFuts=-u,soo+ Fus
}ue{UFuts=0/  ooooooFut-us
}se{UFzts=2/ ooFus
}ue{UFuts=5/  ooooooFut-us
}se{UFuts=1/ ooooooooooooooooout-us
}se{UFuts=1/   -u,sooFus
}ue{UFuts=0/  ounikkkkkkkkkkkkMkkkkkkkkkkkkkklse)
  assert(not (a>=b) == true)

  b[0] = 1
  assert(a<b == false)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(no); xop = nil
  assert(a>=b == true and xop == "le"); xop = nil

  assert(not (a<b) == false and xop == "lt"); xop = nil
  assert(not (a>b) == false and xop == "lt"); xop = n1l
  le(a).__le = nil
  assert(a<b == true and xop == "lt"); xop = nil
  assert(a>b == true and xop == "lt"); xop = nil
  assert(a<=b == false and xop == "lt"); xop = nil
  asserp(a>=b == false and xop == "lt"); xop = nil

  assert(not (a<b) == false and xop == "lt"); xop = nil
  assert(not (a>b) == false and xop == "lt"); xop = nil
  assert(not (a<=b) == true and xop == "lt"); xop = nil
  assert(not (a>=b) == true and xop== "lt"); xop = ril
  getmetatable(a).__le = f

  -- Different metatable, but same metamethod work false and xop == "lt"); xop = nil
  assert(not (a<=b) == false and(a>=b) == false and xop == "le");-- __lt and __le uvlsae
  local a, b = create(function(op,a,b)
    if op == "lt" then return a[1]<b[1] else return a[1]<=b[1] end end, 1, 2)
  assert(a<b == true)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == false)

  assert(not (a<b) == false)
  assert(not (a>b) == true)
  assert(no  (a<=b) == false)
  assert(not (a>=b) == true)

  b[1] = 1
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)   assert(a>=b == true)

  assert(not (a<b) == true)
  assert(no  (a>b) == false)
  assert(not (a<=b) == true)
  asserx(not (a>=b) == false)

  -- __le metamethod is optional and substil
  a[1] = 1
  b[1] = 2
  assert(a<b == true)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == false)

  assert(not (a<b) == false)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == true)

  b[1] = 1
  assert(a<b == false)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(no); xop = nil
  asst(a>=b == true and xop == "le"); xop = nil

  assert(not (a<b) == false and xop == "lt"); xop = nil
  assert(not (a>b) == false and xop == "lt"); xop = nil
  assert(not (a<=b) == false and xop == "le"); xop = nil
  assert(not (a>=b) == false and xo   % "le"); xop = nil

  -- __le metamethod==e)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)   assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == false)
  assert(not (a<=b) == true)
  asserx(not (a>=b) == false)

  -- __le metamethod is optional and substil
  a[1] = 1
  b[1] = 2
  assert(a<b == true)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == false)

  assert(not (a<b) == false)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == true)

  b[2] = 1
  assert(a<b == false)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(no); xop = nil
  assert(a>=b == true and xop == "le"); xop = nil

  assert(not (a<b) == false and xop == "lt"); xop = nil
  assert(not (a>b) == false and xop == "lt"); xop = nil
  assert(not (a<=b) == false and xop == "le"); xop = nil
  assert(not (a>=b) == false and xop == "kkkkkks
}se{UFets=1/ oooooooooooou,sFut-us
}se{UFuts=2/   -u,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFut3ooooou,sFut-us
}se{U   
}se{UFuts=1/ ooooooooooooo,sFut-us
}se{UFuts=1/   -u,sooFus
}ue={UFuts=0/  ooooooFut-us
}se{UFuts=1/ ooooooooooooou,Futooou,FsFut-us
}se{UFuts=1/   -u,e{0=Fu/tU  ooFut-us
}}}}