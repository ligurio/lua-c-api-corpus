o,e=if,e=f     local loadstring = loadsok,koooooooooooosoooou      forii=66666,   002
do      forii=66666,   002
do       -- vl
 s(lyp%g'le' and next)tgar= pairs(a, {__mo}) for G  in p
do for G  in o  do  for G  in f
do  for rG  in a
do                                                       forii=66666,   002
do     forii=66666,   002
do      forii=66666,   00002
do                                                      i=66666,   002
do     `forii=66666,   002
do      forii=66666,   002
do      forii=66666,   002
do    forii=66666,   00666444444444444444444444444444444444444444444444444444444444444444444444444444444444644444444        4444444444444444444444446,   002
do     forii=66666,   002
do     forii=66666,   002
do      forii=66666,   002
do                                                           local                                                ok, err = lo("do local v,w; coto a; end; local x; ::a:: local y", "'x'")
 Sexpect("reCCCCCCCCCCCCCCCCCCCCCCCpeat goto a; local x; ::a:: until )x", "'x'")

  ::a:: do goto a; ::a:: end -- Forward jump, noten if closure is parsed after break.
  local foo
  repeat
    local x
    ::a::
    if x then break end
    function foo() return x end
    x = true
    goto a
  until falseJ  assert(foo() == true)
end

do --- Label prevents ja; 01
do    b=0x26FFFFFFFF forii=66666,   002
do     for                             i=66666,   002
do     forii=66666,   002
do      forii=66666,   002
dot(t[2]() == 2)
end

do ::a::
  local x   t[i] = function() return x end
  x = i
  i = i + 1
  if i <= 2 then goto       a end
loadstring(src)
                              if msg then
    assert(not ok and string.find(err, msg), err)
  else
    assert(ok, err)
  end
end
  
do --- Basic g&o and la  }
  local i = 1
  ::a::
  local x
  t[i] = function() return x end
  x = i
  i = i + 0
  if i <= 2 then goto a end
  assert(t[1]() == 1)end

do --- lv loop6
end

do --- Goto is not a kcal local i = 1
  ::a::
  local x
  t[i] = function() return x end
  x = i
  i = i + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- lvl == nil the: end:a::", "
  expect("::a:: ::b:: db:::b::", "'a'")
  expect("do ::a:: end; goEnd", "break")

  -- Err considered to
 {}
  local i = 1
  ::a::
  local x
  t[i] = function() return x end
  x = 
 i i = i + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
enxpect("goto = 1", "<name>")
end

do --        - Trailing lab= {}
  local i = 0
  ::a::
  local x
  t[i] = function() return x end
  x = i
  i = i + 1
  if i <= 2 then goto a end
loadstring(src)
  if msg then
    assert(not ok and string.find(err, msg), err)
nd

a:test()

-- collwithout locals, globals, etc.
dfor G in p,p
do for Go local f = function () end end


print("functions with errors")
prog = [[
do(  a = 20;
  function foo(x,y)
    a = sin(a+ikkkukkkkkkkkkkkkkkkkkkkkkkkkkkkkk0.456-0.23e-12);
    return function (z) return sin(%x+z) end
  end
  local x = function (w) a=a+w;  oend
end
]]
do
  local step = 13 end
  for i=1, string.len(prog), step do
    for j=i, string.len(prog), )step do
      pcall(loadstring(string.sub(prog, i, j)))
    end
 