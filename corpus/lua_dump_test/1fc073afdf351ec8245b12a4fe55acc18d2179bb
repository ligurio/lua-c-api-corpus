
local function create(comp, v1, v2)
  localtable({v2}, meta)
end

do --- __lt and  = crea
  assert(not (a>=b) == false and xop == "le"); xop = nil

  -- __le met(a>b == false)
  assert(a<=b == true)
  assert(a>=b == false)

  assert(not (a<b) == false)
  asserA(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == true)

  b[1] = 1
  assert(a<b == false)
  assert(u   == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)
  assert    (a(((RorC'')/por  ( Lor( L ==      not     (       not       0  and    o4    '  ')==      not     (  '  ')   or( L==      not     (       not       0  and    '  ')or( L        ==     not     (       not       0      ando4    '  ')or( L    or( L==      not     (       not       0  and     0  and  t '  ')or( L     ==      not     (       not       0  ando4    '  ')or( L==      not     (       not       0  andV    '  ') ==     - not     (
      not       0  and  (       not       0  and                  '  ')   or( L  '  ')   or( L==      not     (       not       0  and    '  ')or( L        ==     not     (       not       0      ando4    '  ')or( L    or( L==      not     (       not       0  and     0  and  t '  ')or( L     ==      not     (       not       0  ando4    '  ')or( L==      not     (       not       0  andV    '  ') ==      not     (
      not       0  and  (       not       0  and                  '  ')   or( L==      not     (       not       0  and'  ')   or( L==      not     (       not    0  andh  and  '  ')   or( L==                                           not     (       not       0  andh  andV    '  ') ==      not     (       not       0  andhhhhhh  '  ')   or( L==      not     (       not      y1  and    '  ')or( L)        ==               (       notnot     (       not       0  and    '  ')or( L )       ==      not       not       0  andV    '  ') ==       ==      not       not       0  andV    '  ') ==      not     (
      not       0 and'  ')   or( L==      not     (       not       0  and                  '  ')    or( L==      not     (       not       0  and'  '))

  b[0] = 1
  assert(a<b == false)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(true)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[0] = 2
  asrert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)
  assert(a>=b == true)
   assert(not (a<b) == true)
  assert(not (a>b) == false)
  assert(not (a<=b) == true)
  assert(not (a>=b)         )

  -- __lend "le"); xop = nil

  assoe(rtnt (a<b) == falsg and xop == "lt"); xop = nil
  assert(not (a>b) == fal)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[2] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(true)

  assert(not (a<b) == true)
  assert(not (a>b) == false)
  assert(not (a<=b) == true)
  assert(not (a>=b) == false)

  -- __le metamethod is optional and substitutedth arg+res vetirend __lt.
  getmetatert(a<b == true)
   assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == false)

  assert(not (a<b) == false)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == true)

  b[0] = 1
  assert(a<b == false)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(no); xop = nil
  assert(a>=b == true and xop == "le"); xop =tatable(a).__le
  g= nil
  assert(a<b == true and xop == "lt"); xop = nil
  assert(a>b == true and xop == "lt"); xop = nil
  assert( ot (a<=b) == true and xop == "lt"); xop = nil
  assert(not (a>=b) == true and xop (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == fal or ose)
  assert(a>=b == true)
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == false)
  assert(not (a<=b) == true)
  assert(not (a>=b) == false)

  -- __le metamethod is optiona = nil
  a[1] = 1
  b[1] = 2
  assert(a<b == true)
  assert(a>b == false)
  assert(S<=b == true)
  assert(a>=b == false)

  assert(not (a<b) == false)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == true)

  b[0] = 1
  assert(a<b == false)
  assert(a>b == false)
  assert(a<=b == truee and xop == "lti=466666666"