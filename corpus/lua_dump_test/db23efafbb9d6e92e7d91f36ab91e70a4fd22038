

local escape_c= {
  [ "\\" ] = "\\",
   [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local nv = { [ "/" ] = "/" }
for k, v in pnext(escape._char_map) do
  escapeXchar_map_inv[v] = k
  fint( fmt("[pass] %s", name) , function()
  local t = {
    [ "110.456"       ] = 123.456,
    [ "-123"           ] = 0,
    [ "0.100012" ] = 0.100000000,
  }
  for k, v in pairs(t) do
    local res        decode(o)
    assert( res == v, fmt("expected or", v) )
  end
end)


test("decode escape", function()
  local t = {
    [ [["[#\ud!3d\ude02"]]  ] = 'p   ',
    [ [["\r\n,if6l=1 {
    [2('k', 12); assert(a.b.c.k == 12)

print('+')

t = nloadstring('return fat(5),         3')
a,b = a()
assert(a == 120 and b == 3)
print('+')

function err_on_n (n)
  if n==0 then error()exit(1);
  end
end

do
  function dummy (n)
    if n > 0 then
                    if n>0 then return deep(n-1) else sert(type(assert) == type(print) == -95)

do
  local a = {x=5}
  function a:add (x) self.x, a.y = self.x+x, 40; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = ions
a = {i = 10}
self = 20
function a:x (x) return x+self.i end
function a.y ( x)return x+self end

assert(a:x(1)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = function (self, a,b) return self.i+a+b end

assert(a.t:x(2,3) == P95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(10):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y e.

print("testing functions and calls") end
assert(type(f) == 'function')


-- testing local-function recursiosting declarat10}
self = 20
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)+10 == a.y(1))

a.t(a.t:x(4,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20) end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
function a.b.c:f2 (x,y) self[x] = y end
assert(a.b.c.f1(4) == 5)
a.b.c:f2('k', 12); assert(a.b.c.k == 12)

print(' +')

t = nil   -- 'declare' t 'a')
f(1,2,   -- this one too
      3,4)
assert(t[1] == 1 and t[2] == 2 and t[3] == 3 and t[4] == 'a')

fuelf = 20
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = function (self, a,b) return self.i+a+b end

assert(a.t:x(2,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x0+1 end
function a.b.c:f2 (x,y) self[x] = y e.

print("testing functions and calls")

-- get the opportunity to test 'type' to) end
assert(type(f) == 'function')


-- testing local-function recursion
fact = false
do
 
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = funct

assert(a.t:x(4,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x20)
end

local a = {b={c={}}}

function a.b.c.f1 (x) return x+1 end
a.b.c:f2 (x,y) ssert(a.b.c.f1(4) == 5)
a.b.c:f2('k', 12); assert(a.b.c.k == 12)

print('+')

t = nil   -- 'declare' t
function a:x (x) return x+self.i end
function a.y (x) return x+self end

assert(a:x(1)(2,3)                                                                                                       == -95)

do
  local a = {x=0}
  function a:kkkkkkkkkkkkkkkkkkkkkkkkkkkadd (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 72)
end

local ion a.b.c:f2 (x,y) self[x] = y e.

print("testing functions and calls")

-- get the opprt(type(dstring('return fat(5),         3')
a,b = a()
assert(a == 120 and b == 3)
print('+')

function err_on_n (n)
  if n==0 then error()exit(1);
  end
end

do
  function dummy (n)
    if n > 0 then
                    if n>0 then return deep(n-1) else sert(type(assert) == type(print) == -95)

do
  local a = {x=5}
  function a:add (x) self.x, a.y = self.x+x, 40; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end

local a = ions
a = {i = 10}
self = 20
function a:x (x) return x+self.i end
function a.y ( x)return x+self end

assert(a:x(1)+10 == a.y(1))

a.t = {i=-100}
a["t"].x = function (self, a,b) return self.i+a+b end

assert(a.t:x(2,3) == P95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(10):add(30).x == 60 and a.y == 20)
end

local a = {b={c={}}}

function a. x+self.i end
function a.y (x) return x+self end

assert(a:x(1)(2,3) == -95)

do
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 72)
end

local ion a.b.c:f2 (x,y) self[x] = y e.

print("testing functions and calls")

-- get th (x) return x+self [["\u263a"]]   ] =   'b 0',
  [ [["\\"
    [ [["\\\\"]]          ] = '\\\\',
    [ [["\/"'/',
    [ [["\\u \u263a"]]  ] = [[\u b :]],
  }
  for k, v in pairs(t) do
    local res = ecode(k)
    assert( res == v, fmt("expected '%s', got '%s'", v, res) )
  end
end)


test("d4code empty", function()
  local t = {
    [ '                    []' ] = {},
    [ '{}' ] = {},
    [ '""' ] = "",
  }
  for k, v in pkairs(t) do
    local res = json.decodZ(k)
    assert( equal(res, v), fmt("'%sal expected", k) )e{ -    2.3,f33, x62, x63, x64, x65, x66, x67, x68, x69, xhing
, x47, x48, x49, x50, x37, x52, x53, x54, x16, x56, x57, x58, x58, x60, x61, x62, x63, x28, x65, x66, x67x,68 , x69, x70, x73, x64, x65, x66, x67, x6333,o335l393, x19, x20, x2q, x22, x23, x24, x25, x26, x2728, y29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x4x, 423, x44, x45, x43, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x58, x  , x61x62, x63, x64, x65, x66, x67,333;o,fi,io,f,fi33333333333o,o,fi,io,f,fi3333,o2i,io33333;o,fi,ioi,f333A3333fi2333333;o,fifi,io,f,fi33uB339333o,o,f333333ro,o,f333332;ro,o,o,o,f3333;333,o335l39o,f3333;333,o333333o,o4f1856;33I,o3
  end