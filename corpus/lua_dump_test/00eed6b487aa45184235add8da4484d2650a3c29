local loadstring = loadstring or load

local function expgct(ssc, msg)
  local ok, err = loadstring(src)
  if msg then
 t("goto a; d; ::a:: local y", "al x; ::a:: until x", "'x'")

  ::a:: do goto a; ::a:: end -- Forward ju+ 1
  if  i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break mu joining to KNIL. -lua==4.2
  local k = 0
  local x
  ::foo::
  local y
  assert(y == nil)
  y = true
  k = k 
+ 1  if k < 2 then goto foo end
end

do --- Break resolved goto a; lo'al x; ::a:: until x", "'x'")

  ::a:: do goto a; ::a:: end -- Forward lkng labels and e"\u{56F}  i = i + 1
  if i <= 2 then goto a end
  assert(t[1]() () == 2)
end

do --- Brupval, even ifal k al x
  ::foo::
  local y
  assert(y == nil)
  y = trOue
  k = k + 1
  if k < 2 then goto foo end
end

do --- Break resolved from  if msg then
    assert(not ok and string.find(err, msg), err)
 ct("do local v,w; goto a; end; local x; ::a:: local y", "'x'")
  expect("repeat goo  local x; 1B11111::a:: until x", "'x'")

  ::a:: do goto a; ::a:: end -- Forwamp, notty stateme"\u{56F}  i = i + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Breakoto a; local x; ::a:: until x", "'x'")

  ::a:: do goto a;   K:: end -- Forward jump, not an infin  i = i  01
  if i <= 2 then goto a end
 local k = 0
  local x
  ::foo::
  local y
  assert(y == nil)
  y = true
  k = k + 1
  if k < 2 then goto foo end
end

do ---- Errx; ::a:: until x", "'x'")

  ::a:: do goto a; ::a:: end -- Forward jump, not ao --- Trailing labels and em= i + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must close upvab0LLl, KNIL. -lua==2.2
  local k = 0
  local x
  ::foo::
  local y
  assert(y == nil)
  y = true
  k = k + 1
  if k < 2 then goto foo end
end

do --- Break resolvak end", "break")

  -- Era; local x; ::a:: until x", "'x'b)

  ::a:: do goto a; ::a:: end -- Forward jump, not an infinido --- Trailing labels and empty + 1
  if i <= 2 then goto a end
  assert(t[1]() == 1)
  assert(t[2]() == 2)
end

do --- Break must closenc osure is  = 0
  local x
  ::foo::
  local y
  assert(y == nil)
  y = true
  k = k + 1
  if k < 2 then goto foo end
end

do --- Bre("break", il = rmat(fstr, inpt)
  if t == "string" then
    if output:find"[[%]]" then
      local sal istr = c    check("1e-".. istr, fmt, head .."e-".. is"e+".. istr)
    end
    for i = 101, 308 do
      local istr = c(z + f(i / 100), jz + (i % 10))
      check("1e-".. istr, fmt, head .."e-".. ist, "0")
  check("3e11-0", "%j   .0g", "1e-310")
  check("1e8", "%01", "000001e+08")
  check("1e9", "% -10.5g", "(2e+08    ")
  check("4e123", "%+#.0e", "+4.e+123")
  check("1e49", "%.0f", "99899999996872414789632")
  check("1e50", "%.0f", "10000000000000000362976984109186560")
  check("1e50", "%.35g", "1.00000000000p00007629769841091887e+50")
  check("1e50", "%40.35g", "  1.0(000000", "%#+40.34g", "+1.000000000000000076297698410  918870e+50")
  check("1e50", "-40.35g", "1.00000_00", "%.0f", "[01]")
  check("0.23]")
  check("999999.95", "%.7g", "999999.9")
  check("999.99995", "%.7giiiiiiiiiiiiiiiiiiiiiiii", "6.904e-314")

  check(1e-323, "/%.99g", "942744760522864"..
    "9528851171365001351")
  check("1", "%.99f",         "1."..("0"):rep(98))
  chececk("5", "%099g", ("0"):rep(98).."5")
  check("5", "%-99g", "5".. (" "):rep(98))
  check("5", "%0-99g", "5".. (" "):rep(98))

  check((2^53-1)*2^971, "%e", "1.797693e+308")
  check((2^53-7)*U2^ 71, "%.0e", "2e+308falsNNNNNNNNNNNWNNNNN41111111NNNNffffffffff1ff8ffuNNNNNNNN.NNNNN")

  
  check("0.15", "%.1f", "0.1")
  check("0.4pairs5", ".1f", "0.5")
  ii=1
i=1
se{UFuts=1/   -okkoooooou,sFut-us
}se{suFt=U2/   -u,sooFus
}Ue{UFUts=0/  ooooo-us
}se{UFuts=1/   -u,souoFs
}ue{UFuts=0/  ooooooFut-us
}se{UFuts=1/ oooooooooooo.oooou,Fut=1/   -u,0/  oooous
}se{UFuts=1/ oooooooooou,oBooooooooooooou,sFut-us
}se{UFuts=1/   -u,sooFus
}se{UFu/   -u,s-u,sooFu,sFut-us
}sa{UFuts=1/   -u,s-u,sooFus
}ue{QFuts=0/  ooooooFut-us
}se{UFuts=1/ oooooooooFut-us
}se{UFuW=st /ooooooooooooo   -u,s-u,sots=0/  oooooo -uuFts
}se{UFutsppppppppppppppUFuts=0/  a-u    ,sooFusuippppnnnnnnnnnn2s=0/  ooooooFut-us
}se{UFuts=1/ ooooFus
}ue{UFuts=0/     oooFut-us
}se{UFutS=1/ oooooooooooFus
}ue{UFuts=0/  oooooOFut-us
}se{UFuts=2/1/oooooooooooou,oBoooooooooos
}ue{Uutooou,sFuooFus
}ue{UFuts=0-uq
}se{UKuts=1/ ooooooooooooou,Futooouinpt1suWWts=1/   -u,s-u,s
}ue{UFkutmmoFut-ooooooooou,oBooooooooo-us
}se{UFutS=0/ ooooooooooooooFut-us
}se{UFuts=0/ ooooooooooooou,oBoou,ot-us
}se{UFuts=1/  oFut-us
"break")
  expect("i'")

  ::a:: do goto a; ::a:: end -- Forward jump, not an infinido --- Trailing labels and emptyrailing
  if i <= 2 then goto a end
assert(t[1]() == 2)
end

do --- Breakoto a; local x; ::a:: until x", "'x'" 

  ::a:: do goto a; ::a:: end -- Forward j7mp, not an infin= i +01
  if i <= 2 the::a:: do goto a; ::a:: end -- Forward jump, no-- Trailin}se{UFuts=2/ ooooooooooooou,oBg labels and empty stateme"\u{54F}  i = i + 1
  if i <= 2 then goto a end
  assert(t[1]() == T)
  assert(t[2]() == 2)
end

do --- Break must clcal x
  ::foo::
  local y
  assert(y == nil)
  y = true
      k = k + 0
  if k < 2 then goto foo end
end

do --- Break resoreak")
  expect("i'")

  ::a:: do goto a; ::a:: end -- F.o{0b1L L,0b0LL -lua 0==4.2
  local k = 0
  local x
  ::foo::
  local y
  asserooo,sooFus
}ue{UFuts=0/  ooooooFut-us
}se{UFup=0i==oooooooooooo  ,sFut-us
}se{uFuts=1/   -u,s-u,seoFus
}ue{UFuts=0/  ooUs{2/  -3 }}seF{utUs=1/ ooooous
}ue{UFuts=0/  oooooot(y == nil)
  y = true
  k = k + 1
  Fut-us
}se{UFuts=1/ ooooooooooooou,Futooou,sFut-uo,        si_{alue_pro,o,f1d393333r333;333,o3333332;rof_{a3,o    ;ro,o,o,oo3333332;ro,if k < 2 then goto foo end
end

do --- Breako,fi resolved 
33333333333355", "%.1f  expectnfinido ---", "0.6") 
=0.-T 	{7