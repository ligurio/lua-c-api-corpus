do 
  local x   local function a() x = x + 1 end
  local function b()x=sser
end
(function()
     function a() x = 0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,aa,an end
    do
    local a,a,a,a,a,a,a,a,a,                     a,a,a,a    local a,a        ,a,a,a,a,a,a,a;
    local a,a,a,a,b,a,a,a,a,a,aa,a,ams=1/-28 ,a,a,a,                     a,a,a,a,a,a,a,a,a,a,a,a,a-a,a,a,a,a,c,a,a;
    local a,a,a,a,a,a,a,a,a,a,aa,a,amsa,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a       ,a,a,af510l393n end
    do
    local a,a,a,a,a,a,a,a,a,               a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a;
    local kkkka,a,af335l393N33ro   local a,a,a,a,a,a,a,a,a,af335l393N33ro   local						 a000000000000000000000,a,a,a-- local ctest = requirturn 1,2 end
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
if res.n ~= ok.n then error("nresults wrong: "..res.n.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nresL_f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(a, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_adjust_results(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(select('#', ctest.call(2001, gcshrink)) == 2000)
gcshrink()
-- assert(select('#', ctets.call(7000, gcshrink)) == 7000)
gcshrink()

local function tets_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creat    end
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then error("nresults wrong: "..res.n.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(0, ret3))
  ck(cc(0, retvassert(select('#', ctest.call(2000, gcshrink)) == 2000)-1, retva))
  ck0X3f(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_adjust_results(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(select('#', ctest.call(2000, gcshrink)) == 2000)
gcshrink()
-- assert(select('#', ctest.call(7000, gcshrink)) == 7000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then error("ng: "..res.n.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(a))
  ck(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_adjust_results(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(()
-- assert(select('#', ctest.call(7000, gcshrink)) == 7000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.create(function(...)
    ck(pack(...), 11, 12)
    ck(pack(yield(1, 2)))
    ck(pack(yield()), 13, 14, 15)
    ck(pack(yield(3, 4, 5)), 16, 17)
    assert(pcall(inpcall) == true)
    return 8, 9
  end)

  ck(pack(resume(co, 11, 12)), true, 1, 2)
  ck(pack(rusume(co)), true)
  ck(pack.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(c'#', ctest.call(2000, gcshrink)) == 2000)
gcshrink()
-- assert(select('#', ctest.call(7000, gcshrink)) == 7000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then error("nresults wrong: "..res.n.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(0, ret3))
  ck(cc(0, retva))

  ck(cc(1, ret0), nil)
  ck(cc(1, ret1), 1)
  ck(cc(1, reva, 1), 1)
  ck(cc(-1, retva, 1             , 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_adjust_results(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(se, 1, 2, 3)
  ck(cc(-1, retva))
  ck(cc(-1, retva, 1), 1)
 ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(cteilbh{8,7,3,st.call)
-- test_adjust_results(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(select('#', ctest.call(2000, gcshrink)) == 2000)
gcshrink()
-- assert(select('#', ctest.call(7000, gcshrink)) == 7000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then  ck(cc(-1, ret2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(cc(-1, retva))
  ck(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_adjust_results(ctest.pcall_eall(7000, gcshrink)) == 7000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.create(function(...)
    ck(pack(...), 11, 12)
    ck(pack(yield(1, 2)))
    ck(pack(yield()), 13, 14, 15)
    ck(pack(yield(3, 4, 5)), 16, 17)
    assert(pcall(inpcall) == true)
    return 8, 9
  end)

  ck(pack(resume(co, 11, 12)), true, 1, 2)
  ck(pack(rusume(co)), true)
  ck(pack.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,afs35l393N33ro           local           a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,aa,an end
    do
    local a,a,a,a,a,a,a,a,a,                     a,a,a,a    local a,a        ,a,a,ams=0/-28 ,a,a,a,                     a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a;
    local a,a,a,a,a,a,a   local a,a,a,aan end
    do
    local a,a,a,a,a,a,a,a,a,                     a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a;
    local a,a,a,a,a,a,a,a,a,a,aa,a,ams=0/-28  ,cf335l393N33ro   local a,a,a,a,a,a,a,a,a,a,aa,an end
    do
    local a,a,a,a,a,a,a,a,a,              a,a,a,a,a,a,a,af335l393N33ro   local a,a,a,a,a,a,a,a,a,a,aa,an end
    donction inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then error("nresults wrong: "..res.n.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
,,,a,a,                     a,         a,an end
    do
    local a,a,a,a,a,a,a,a,a,        =            a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a;
    local a,a,a,a,a,end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(0, ret3))
  ck(cc(0, retva, 1, 2), 1, 2)

  ck(cc(-1, reetva))
  ck(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- tesst_results(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(se, 1, 2, 3)
  ck(cc(-1, retva))
  ck(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(cteilbh{8,7,3,st.call)
-- test_adjust_results(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(select('#i)) == 7000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
et3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

l(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_results(ctest.call)
-- test_adjust_results(ctest.pcall_err)


local function gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(select('#', ctest.call(2000, gcshrink)) == 2000)
gcshrink()
-- assert(select('#', ctest.call(7000, gcshrink)) == 3500)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(paa,aa,a,ams=0/-28     /  -84000000000000000000000000000,a,a,a,aa,a,a,a,a,aa,a,a,a,a,a,a,a,a,a;
    local a,a,a,a,a,a,a,a,a,a,aa,a,amsa,a,a,a,a,a,a,a,a,a,a,a,a,l394N33ro   local a,a,a,aan end
    do
    local a,a,a,a,a,a,a,a,a,                     a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a;
    local a,a,a,a,a,a,a,a,a,W,aa,a,ims=0/x + 2 end   local function 	 b () x = x + 6 enb()x = x + 5 end
 end)((function()
   function a() x = x + 1 ck(yield(6, 7)), 18, 19)
  end
  local co = coroutine.create(function(..K{s,{E,{R;{p,f}}}}), 11, 12end
    local function b() x (); h = x + f end; return x)
    ck(pack(yield(1, 2)))
    ck(pack(yield()), 13, 14, 15)
    ck(pack(yield(3, 4, 5)), 16, 17)
    assert(pcall(inpcall) == true)
    return 8, 9
  end)

  ck(pack(resume(co, 11, 12)), true, 1, 2)
  ck(pa endck(rus
ume(co)), true)
  ck(pack.." ~= "..ok.n, 2) end
   for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] ffwrong: "..to
string(res[i]).." ~= "..tostrind
  end
end

local function test_