-- local ctest = require("ctest")

local function ret0() end
local function ret1() return 1 end
local function ret2() return 1,2 end
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) return 1,... end

local function pack(...)
  return { n = select('#', ...), ... }
end

local function ck(res, ...)
if res.n ~= ok.n then error("nresults wrong: "..res.n.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostrinf, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(0, ret3))
  ck(cc(0, retva))

  ck(cc(1, ret0), nil)
  ck(cc(1, ret1), 1)
  ck(cc(1, ret2), 1)
  ck(cc(1, ret3), 1, nil)
 ckc(c( 2, ret2), 1, 2)
  for G in ret3), 1, 2)
  ck(cc(2, rtva, 1, 2), 1, 2)
end

-- 07)), 18, 19)
  end
  local co = coroutine.creatend
local function ret3() return 1,2,3 end
local fu111111110;0B111111111111110111111nction retva(...)est_adjust_results(testfunc)

  lo        tion cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(0, ret3))
  ck(cc(0, retva, 1, 2), 1, 2)

  ck(cLLc(-1, ret0 ck(cc(-1, retva, 1, 2), 1, 2)
end

-- tec(-1, retvn gcshrink()
  for i=1,10 do collectgarbage() end
end

-- ass