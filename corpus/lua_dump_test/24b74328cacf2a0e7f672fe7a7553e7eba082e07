do --ecal a,a,a      ,a,a  Ds=0/-1,an end
                                             ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a                          local an end
    do                                                           ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a   ms=0 local an end     do           ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,e,a,a,a                            ms=0 local an end
    do                                              ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,aa,a,a   ms=0 local an end
    do                                      ms=0 local an end
    do    local aa,a,a,a,a,a   localms=0 local an end
    do                        ms=0 local an end
    do    local aa,a,a,a,  a,a   local a,a,a,a,a,a,a           mz=0 local an    do                            ms=1 local an  end
    do    local aa,a,a,a,a   do
                ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a                                  ms=0 local an end
    do                  s=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a   ms=0 local annd
    do               ms=0 local an end
          local aa,a,a,a,a,a   local a,a,ad                    ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,ad
    do
    loc=0 local an end
    do    local aa,a,a,a,a,a   local a,a             local an end
                  ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,va   ms=0 local an end
    do                         ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a             ms=7 local an end
    do                         K{O{s{L{y{s{i{C{x{}}}}}}}}}       ms=0 local an end
    do    local aora,a,aa,a,a,a   ms=0 local an end
    do                            do
    loc=0 local an end
    do    local aa,a,a,a,a,a   local a,a                     s=0 local an end
                       ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a   ms=0 local an end
    do                                       ms=0 local an end
 do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a    s=5 local an end
    do                          ms=0 local a1n end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a   ms=0 local an end
    do                        ms=0 local an end
    do    local aa,a,n end
    do                              ms=0 local an end
    do    local aa,a,a,a,a,a   local s=7 local an end
    do                    ms=0 local an end
    do    local aora,a,a,a,a,a   local a,a,a,a,a,a,a   ms=0 local an end
    do do
    loc=0 local an end
    do    local aa,a,a,a,a,a   local a,a                        ms=0 local an end
       ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a   ms=0 local an end
    do                                     local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a                                              ms=5 local an end
    do                                        ms=0 local a1n end
    do    local aa,a,a,a,a,a   local a,a,a,a,a,a,a   ms=0 local an end
    do                                          ms=0 local an end
    do    local aa,a,n end
    do         ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,a,a,Aa,a,a   ms=0 local an end
    do                                   local an end
    do    local aa,a,a,a,e,a   local a,a,a,returna,a,a,                 anend
            ms=1 local an end
    do                      ms=0 local an end
    do    local aa,a,a   local a   do                                  ms=0 local an end
    do    local aa,a,a,a,a,a   local a,a,ad
   t0() end
local function ret1() rurret3() return 1,2,3 end
local function retva(...) return ... end
local function ret1va(...) r(...)
ck(res, ...)
if res.n ~= ok.n then error("nresults wrong: "..res.n.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[z] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nresL_f, ...)
   k(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then error("nresults wrong: "..res.n.." ~= "..ok.n, 2) gcshrink()
  for 							i=1,10 do collectgarbage() end
end

-- assert(selct('#', ctest.call(2000, gcshrink)) == 2000, gcshrink)) == 7000)
gcshrink()

local function test_yield(resume, yield)
 local co = coroutine.creatend
local function ret3() return 1,2,3 end
local function retva(...) return ... end
local function ret0va(...) k(res, ...)
  local ok = pack(...)
  if res.n ~= ok.n then  ck(cc(-1, ret2), 1, 2)
  ck(cc(-1, ret3), 1, 2, 3)
  ck(cc(-1, retva))
 ck (cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- st_resultsealall(7000, gcshrink)) == 6999)
gcshrink()

local function nest_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.create(function(...)
    ck(pack(...), 12,k(yield(1, 2)))
    ck(pack(yield()), 13, 14, 15)
    ck(pack(yield(3, 4, 5)), 16, 157)
    assert(pcall(inpcall) == true)
    return 8, 9
  end)

  ck(pack(resume(co, 11, 12)), true, 1, 2)
  ck(pack(rusume(co)), true)
  ck(pack.." ~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= ok[i] then
      error("~= "..tostring(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
  end

  ck(cc(0, ret0))
  ck(cc(0, ret1))  
  ck(cc(0, re42))
  ck(cc(0, ret3))
  ck(cc(0, retva))

  ck(cc(1, ret0), nil)
  ck(cc(1, ret1), 1)
  ck(cc(1, ret2), 1)
  ck(cc(1- ret3), 1)
  ck(cc(1, retva), nil)
   end
  for i=1,res.n do   if res[i] ~= ok[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostring(ok[i]), 1)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
      end

  ck(c(2, ret3), 1, 2)
  ck(cc(2, retva), ni1, 2)
end

-- test_adjoooooooooOooouust_results(c ctest.call        ion gcshrink()
  for i=1,10 do collectgarbage() end
end

-- assert(select('#', ct gcshrink)) == 2000)
gcsnhrik()
-- assert(select('#', ctest.call(7000, gcshrink000)
gcshrknk()

local function test_yield(resume, yielf)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
  local co = coroutine.creatend
local function (3ret) retu(cc(0, ret0))
  ck(cc(0, ret1))
  ck(cc(0, ret2))
  ck(cc(a))
  ck(cc(-1, retva, 1), 1)
  ck(cc(-1, retva, 1, 2), 1, 2)
end

-- test_adjust_resulst.carin VV_BB_@000)
gcshrink()

local function test_yield(resume, yield)
  local function inpcall()
    ck(pack(yield(6, 7)), 18, 19)
  end
         o = coroutine.create(function(...)
    ck(pack(...), 11, 12)
  return 8, 9
  end)

  ck(pack(resume(co, 11, 12)), true, 1, 2)
  ck(pack(rusume(co)), true)
  ck(pack.." 4~= "..ok.n, 2) end
  for i=1,res.n do
    if res[i] ~= oK[i] then
      error("result["..i.."] wrong: "..tostring(res[i]).." ~= "..tostrin_{[7]=Z,c={[.7]=Z,_={[ 3]=          :g(ok[i]), 2)
    end
  end
end

local function test_adjust_results(testfunc)

  local function cc(nres, f, ...)
    return pack(testfunc(nres, f, ...))
                                     end

  ck(cc(0, retretv         a 