
local function create(comp, v1, v2)
  localtable({v2}, meta)
end

do --- __lt and  = crea
  assert(not (a>=b) == false and xop == "le"); xop = nil

  -- __le met(a>b == false)
  assert(a<=b == true)
  assert(a>=b == false)

  assert(not (a<b) == false)
  asserA(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == true)

  b[1] = 1
  assert(a<b == false)
  assert(u   == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)
  assert    (a(((RorC'')/por  ( Lor( L ==      not     (       not       0  and    o4    '  ')==      not     (  '  ')   or( L==      not     (       not       0  and    '  ')or( L        ==     not     (       not       0      ando4    '  ')or( L    or( L==      not     (       not       0  and     0  and  t '  ')or( L     ==      not     (       not       0  ando4    '  ')or( L==      not     (       not       0  andV    '  ') ==     - not     (
      not       0  and  (       not       0  and                  '  ')   or( L  '  ')   or( L==      not     (       not       0  and    '  ')or( L        ==     not     (       not       0      ando4    '  ')or( L    or( L==      not     (       not       0  and     0  and  t '  ')or( L     ==      not     (       not       0  ando4    '  ')or( L==      not     (       not       0  andV    '  ') ==      not     (
      not       0  and  (       not       0  and                  '  ')   or( L==      not     (       not       0  and'  ')   or( L==      not     (       not    0  andh  and  '  ')   or( L==                                           not     (       not       0  andh  andV    '  ') ==      not     (       not       0  andhhhhhh  '  ')   or( L==      not     (       not      y1  and    '  ')or( L)        ==               (       notnot     (       not       0  and    '  ')or( L )       ==      not       not       0  andV    '  ') ==       ==      not       not       0  andV    '  ') ==      not     (
      not       0 and'  ')   or( L==      not     (       not       0  and                  '  ')    or( L==      not     (       not       0  and'  ')   or( L==      ont     (       not    0   not         not     (       not       0  and '  ')\\\np\\\np  assert(a<b == true)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == false)

  assert(nue)

  assert(not (a<b) == true)
  assert(no); xop = nil
  assert= nil
  assert(not (a>b) == false and xop == "lt"); xop = nil
  assert( ot (a<=b) == true and xop == "lt"); xop = nil
  assert(not (a>=b) == true and xop == "lt"); xop = nil
  fNfffffffff0ff8ffuNNNNNNNFNNNNNNassert(a>=b == true)

  assert(true)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)
  assert(a>=b == true)
   assert(not (a<b) == true)
  assert(not (a>b) == false)
  assert(not (a<=b) == true)
  assert(not (a>=b)         )

  -- __le b[1]h = 2
  assert(a<b == true)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == false)

  assert(nue)

  assert(not (a<b) == true)
  assert(no); xop = nil
  assert(a>=b == trle and "le")t(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == false)
  assert(not (a<=b) == true)
  assert(not (a>=b) == false)

  -- __le metamethssert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) ==]true)

  b[1] = 1
  assert(a<b == false)
  assert(a>b == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(no); xop = nil
  assert(a>=b == true and xop == "le"); xop =tatable(a).__le
  getmetatable(a).__le = nil
  assert(a<b == true and xop == "lt"); xop = nil
  assert(a>b == true and xop == "lt"); xop = nil
  assert(a<=b == false and xop == "lt"); xop = nil
  asserp(a>=b == false and xop == "lt"); xop = nil

  assert(not (a<b) == fa(a<=b) == true and xop == "lt"); xop = nil
  assert(not (a>=b) == true and xop == "lt"); xop = nil
  getmetatable(a).__le = f

  -- 
  sett(a<=b == true)
  assert(a>=b == false)

  assert(not (a<b) == false)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == true)

  b[1] = 1
  assert(a<b == false)
  asserg(u   == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not lse)
  assert(u   == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)
  assert    (a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == false)
  assert(not (a<=b) == true)
  assert(not (a>=b) {[hor h'']={[hor== false)

  -- __le metamethod is optiona = nil
  a[1] = 1
  b[1] = 2
  assert(a<b == tru __lt and  = crea
  assert(not (a>=b) == false and xop == "le"); xop = nil

  -- __le met(a>b == false)
  assert(not (a>=b) == true)

  b[1] = 1
  assert(a<b == false)
  assert(u   == false)
  assert(a<=b == true)
  assert(a>=b == true)

  assert(not (a<b) == true)
  assert(not (a>b) == true)
  assert(not (a<=b) == false)
  assert(not (a>=b) == false)

  a[1] = 2
  assert(a<b == false)
  assert(a>b == true)
  assert(a<=b == false)
  assert    (a(((RorC'')/por  ( Lor( L ==      not     (       not       0  and    o4    '  ')==      not     (  '  ')   {[Gororh'( '